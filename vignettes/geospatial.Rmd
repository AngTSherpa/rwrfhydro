---
title: "Spatial tools"
author: "Arezoo Rafieeinasab & Aubrey Dugger"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
For most of the postprocessing, there is a need to create spatial maps, aggregate over spatial units and also produce georeference raster and shapefiles. Many of the existing functions in available spatial libraries such as SP, RGDAL, RGEOS and Raster has been wrapped to serve our purpose. Here we explain these spatial functions, their application and bring some examples.

## List of the available functions
- Getproj
- GetGeogridSpatialInfo
- ExportGeogrid
- GetGeogridIndex
- GetTimeZone
- GetRfc
- GetPoly
- PolygonToRaster

The case study data should be placed at the following directory in order to use the following vignette without changing any line.

```{r}
path.expand("~")
```

```{r}
fcPath <- '~/wrfHydroTestCases/Fourmile_Creek_newGMD'

```

Explain here about geogrid file

```{r}
geoFile <- paste0(fcPath,'/DOMAIN/geo_OrodellBasin_1km_8nlcd11.nc')
```

```{r}
library(rwrfhydro)
```

## GetProj

Pull projection information of WRF-Hydro modeling domain from geogrid file. It takes only `geoFile`: The geogrid file information and return Character Projection

```{r}
proj4 <- GetProj(geoFile)
proj4
```

## GetGeogridSpatialInfo

It pull necessary geospatial information about WRF-Hydro modeling domainfrom geogrid file used for regridding and deprojection.
It only regires the address to the geogrid file and return spatialDF data frame containing geospatial information.

```{r}
geoInfo <- GetGeogridSpatialInfo(geoFile)
geoInfo
```


## ExportGeogrid

If you need to create a georeferenced TIF file from any variable in a netcdf file, you will need to use `ExportGeogrid` function. It takes a NetCDF file having lat/lon information and converts the specified variable into a georeferenced TIF file for use in standard GIS tools. Let's export one of the variable from the geogrid file. You can get a list of all available variables in the `geoFile` using `ncdump` function.

```{r, eval = FALSE}
head(ncdump(geoFile))
```

Now we will create a georeferenced TIF file from HGT_M field. You only need to provide the address to geogrid file, the name of the variable and the name of the output file.

```{r}
ExportGeogrid(geoFile,"HGT_M", "geogrid_hgt.tif")
```

You can now use the created file in any standard GIS platform. Herw we will just read it into memory as a raster and dispaly it.

```{r plot1, fig.width = 8, fig.height = 8, out.width='600', out.height='600'}
# read the tiff file
r <- raster::raster("geogrid_hgt.tif")

# plot the tiff file
raster::plot(r, main = "HGT_M")

# check the raser information and notice coordinate information has been added
r
```


Many of the input and output files such as LDASOUT output file does not contain lat/lon coordinates but matches the spatial coordinate system of the geogrid input file. In that case, you could feed the geogrid file `geoFile` which the lat/lon information will be taken from that file. 

```{r plot2, fig.width = 8, fig.height = 8, out.width='600', out.height='600'}
file = paste0(fcPath,"/RUN.FLUXCOMP/OUTPUT_ALLRT_MAY13_HOURLY/RESTART.2013060100_DOMAIN1")
# ncdump(file) # check if the SOIL_T exist in the file

ExportGeogrid(file,
             inVar="SOIL_T",
             outFile="20130315_soilm3.tif",
             geoFile=geoFile,
             inLyr=3)
# read the tiff file
r <- raster::raster("20130315_soilm3.tif")

# plot the tiff file
raster::plot(r, main = "Soil Temperature")

# check the raster information and notice coordinate information has been added
r
```


## GetGeogridIndex

To be able to use a bunch of tools such as `GetMultiNcdf` one needs to have the indices (x,y). `GetGeogridIndex` get geogrid cell indices from lat/lon (or other) coordinates. `GetGeogridIndex` reads in a set of lat/lon (or other) coordinates and generates a corresponding set of geogrid index pairs. Yo can assign a projection to the points using `proj4` argument which will be used to transform the point to the `geoFile` coordinate system.

```{r}
sg <- data.frame(lon = seq(-105.562, -105.323, length.out = 10), 
                 lat = seq(40.0125, 40.0682, length.out = 10))
GetGeogridIndex(sg, geoFile)
```


## GetTimeZone

Many of the point observation are reported in local time and needs to be converted to UTC time to be comparable with WRF-Hydro input and outputs. `GetTimeZone` return the time zone for any point having longitude and latitude. It simply takes a dataframe containing at least two fields of `latitude` and `longitude`, overlays the `points` with a timezone shapefile (can be downloded from <http://efele.net/maps/tz/world/>). The shapefile is provided in rwrfhydro data and it is called `timeZone`.

```{r}
library(rwrfhydro)
class(timeZone)

# Shows the available timezone, name of the column is TZID
head(timeZone@data)
```

Function has three aruguments. 

- `points`: A dataframe of the points The dataframe should contain at least two fields called `latitude` and `longitude`.
- `proj4`: Projection of the `points` to be used in transforming the projection to `timeZone` projection. Default is "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0") which is the `timezone` projection.
- `parallel`: Logical(DEFAULT = FALSE)

It will return the points dataframe with an added column called `timeZone`. It will return NA in case the point is not in any polygon. Care should be taking for the NA values.

```{r}
# Provide a dataframe of 10 points having longitude and latitude
sg <- data.frame(longitude = seq(-110, -80, length.out = 10),
                 latitude = seq(30, 50, length.out = 10))

# Find the time zone for each point
sg <- GetTimeZone(sg)
sg
```

## GetRfc

Many of the statitics are preferred to be grouped into River Forecast Center level. The RFC boundary shapefile is provided in rwrfhydro data and it is called `rfc`. 
```{r}
class(rfc)

# Shows the available rfc, name of the column is BASIN_ID
head(rfc@data)
```

`GetRfc` return the RFC name for any point having `longitude` and `latitude`. It takes a dataframe containing at least two fields of `latitude` and `longitude`, overlays the points with a `rfc` SpatialPolygonDataFrame. Function has three aruguments. 

- `points`: A dataframe of the points The dataframe should contain at least two fields called "latitude" and "longitude".
- `proj4`: Projection of the `points` to be used in transforming the projection to `rfc` projection. Default is "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0").
- `parallel`: Logical(DEFAULT = FALSE)

It will return the points dataframe with an added column called `rfc`. It will return NA in case the point is not in any polygon. 


```{r}
# Provide a dataframe of 10 points having longitude and latitude
sg <- data.frame(longitude = seq(-110, -80, length.out = 10), 
                 latitude = seq(30, 50, length.out = 10))

# Find the rfc for each point
sg <- GetRfc(sg)
sg
```

## GetPoly

`Getpoly` is similar to `GetRfc`, it is a wrapper for `sp::over`. It takes a dataframe containing at least two fields of `latitude` and `longitude`, overlays the points with a SpatialPolygonDataFrame ans return the requsted attribute from polygon. 

One could use the available SpatialPolygonDataFrame loaded in memory:
  
```{r}
# Provide a dataframe of 10 points having longitude and latitude
sg <- data.frame(longitude = seq(-110, -80, length.out = 10), 
                 latitude = seq(30, 50, length.out = 10))

# Find the RFC for each point
sg <- GetPoly(points = sg, polygon = rfc, join = "BASIN_ID")

# Find the full name of RFC for each point
sg <- GetPoly(points = sg, polygon = rfc, join = "RFC_NAME")

# Find the location/city of RFC for each point
sg <- GetPoly(points = sg, polygon = rfc, join = "RFC_CITY")
sg
```

Or you could read  from a polygon shapefile:
 
```{r}
# Provide a dataframe of 10 points having longitude and latitude
sg <- data.frame(longitude = seq(-105.562, -105.323, length.out = 10), 
                 latitude = seq(40.0125, 40.0682, length.out = 10))

# Find the HUC12 where each point fall into
polygonAddress <- paste0(path.expand(fcPath), "/polygons")

# Reading the shapefile is done using rgdal::readOGR and does not accept `~`
# Edit the polygon address to get rid of this problem
sg <- GetPoly(points = sg,
              polygonAddress = polygonAddress,
              polygonShapeFile = "clipped_huc12",
              join = "HUC12")
sg
```

## PolyToRaster

If one wants to create a mask in the model domain (geogrid file) then one needs to use PolyToRaster. It first picks up the required geographic information (like `proj4`) from the geogrid file (`geoFile`) and then use `raster::rasterize` function to grab the mask or attibute values from the `SpatialPolygonDataFrame`. This is basically wrapping the raster::rasterize fucntion. Below is a few different way one could use this function.

Example 1 : rasterize the `rfc` `SpatialPolygonDataFrame` based on the `BASIN_ID`.

```{r plot3, fig.width = 8, fig.height = 8, out.width='600', out.height='600'}
r <- PolyToRaster(geoFile = geoFile,
                  useRfc = TRUE,
                  field ="BASIN_ID")
```

To know what are the corresponding values to the integer values used in rasterized output :

```{r}
r@data@attributes 
```

As the result shows all the case study domain falls into one RFC. 

Example 2 : rasterize the HUC12 `SpatialPolygonDataFrame` based on the `HUC12` field. The clipped HUC12 shapefile is provided with the test case which is quite larger than the model domain. You could read the shapefile and plot it as below.
```{r plot4, fig.width = 8, fig.height = 8, out.width='600', out.height='600'}
polyg <- rgdal::readOGR(paste0(path.expand(fcPath), "/polygons"), "clipped_huc12")
raster::plot(polyg, main = "Clipped HUC12")
```

Our study domain partially covers a few basins at northeast of this shapefile.

```{r plot5, fig.width = 8, fig.height = 8, out.width='600', out.height='600'}
polygonAddress <- paste0(path.expand(fcPath), "/polygons")
r <- PolyToRaster(geoFile = geoFile,
                  polygonAddress = polygonAddress,
                  polygonShapeFile = "clipped_huc12",
                  field ="HUC12")

r@data@attributes 
```

Example 3: You can get a unified mask over the study domain as follows:
```{r plot6, fig.width = 8, fig.height = 8, out.width='600', out.height='600'}
r <- PolyToRaster(geoFile = geoFile,
                  polygonAddress = polygonAddress,
                  polygonShapeFile = "clipped_huc12",
                  mask =TRUE)
```

Example 4: You could also get a separate mask for each subbasin (HUC12 in this case) with the fraction of each grid cell that is covered by each polygon. The fraction covered is estimated by dividing each cell into 100 subcells and determining presence/absence of the polygon in the center of each subcell. 


```{r plot7, fig.width = 8, fig.height = 8, out.width='600', out.height='600'}
r <- PolyToRaster(geoFile = geoFile,
                  polygonAddress = polygonAddress,
                  polygonShapeFile = "clipped_huc12",
                  field = "HUC12",
                  getCover = TRUE)
raster::plot(r)
```

